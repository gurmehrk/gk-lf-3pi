 target C {
  platform: "RP2040",
  threading: false,
  keepalive: true
}

import Display from "lib/Display.lf"

preamble {=
  #include <hardware/gpio.h>
  #include <hardware/irq.h>
  #include <pico/stdlib.h>
  #define ALARM_NUM 0
=}


main reactor {
    disp = new Display()

  preamble {=

    typedef void (*virtual_timer_callback_t)(void);
    static bool led_state = true;
 
    // Definition of linked list node 
    typedef struct node_t {
      /* Put the variables needed for linked list node here */
      // value for the timer
      uint32_t timer_value;
      uint32_t alarm_num;
      void * callback_ptr;
      bool cancel_node;
      void * time_id;
      bool is_repeated;
      uint32_t repeat_interval;

      /*********************************************
          DO NOT CHANGE THE CODE BELOW
      *********************************************/
      // next node pointer
      struct node_t * next ;
      } node_t ;

    //The linked list for timer
    static node_t* linked_list = NULL;

    // linked list operation functions
    // insert the node in the sorted linked list (linked_list) and return the sorted linked list after the insertion
    void list_insert_sorted(node_t* node){
       if(linked_list == NULL){
          node -> next = NULL;
          linked_list = node;
       }
       else{
          if(linked_list -> timer_value > node -> timer_value){
              node -> next = linked_list;
              linked_list = node;
            }     
          else{
              // node is somewhere after the head
              node_t* prev_node = linked_list;
              node_t* curr_node = linked_list->next;
              while(curr_node != NULL && curr_node -> timer_value < node -> timer_value){
                  // iterate until end of list or the current node has a greater value
                  prev_node = curr_node;
                  curr_node = curr_node -> next;
              }
              // insert node
              prev_node -> next = node;
              node -> next = curr_node;
          } 
       }
    }
    // remove the node from linked list
    void list_remove(node_t* node){
        if(linked_list != NULL){
            if(linked_list == node){
                linked_list = linked_list -> next;
            }
            else{
                node_t* prev_node = linked_list;
                node_t* curr_node = linked_list -> next;
                while(curr_node != NULL && curr_node != node){
                    prev_node = curr_node;
                    curr_node = curr_node -> next;
                }
                if(curr_node != NULL){
                    prev_node -> next = curr_node -> next; 
                }
            }
        }
    }
    // return and remove the first node in the linked list
    node_t* list_remove_first(){
      node_t* head = linked_list;
      if (head != NULL) {
          linked_list = head->next;
      }
      return head;
    }
    /*********************************************
        DO NOT CHANGE THE CODE ABOVE
    *********************************************/

    /* You can also create your own linked list functions here. */
    void led_toggle(void) {
        gpio_put(PICO_DEFAULT_LED_PIN, !led_state);
        led_state = !led_state;
    }   

    void lab5_timer_irq_handler(void) {
        /* TODO */
    
        // Call function & clear status bit
        node_t* latest_head = list_remove_first();        
        
        // If repeated, then adjust timer_value + reinsert
        if (latest_head->is_repeated) {
            latest_head->timer_value += latest_head->repeat_interval;
            list_insert_sorted(latest_head);
        }
        else if (!latest_head->is_repeated && !latest_head->cancel_node) {
            free(latest_head);
        }
        
        if (latest_head->cancel_node) {
            list_remove((node_t *) latest_head->time_id);
            free((node_t*) latest_head->time_id); // time_id points to the node that needs to be canceled
            free((node_t*) latest_head);
        }
        else 
        {
            ((virtual_timer_callback_t) (latest_head->callback_ptr))(); // CALL callback function associated.
            hw_clear_bits(&timer_hw->intr, 1u << 0); // Clear interrupt status, alarm_num = 0
        }
                
        // update timer_value
        if (linked_list->timer_value) {
            timer_hw->alarm[0] = (uint32_t) linked_list->timer_value;
        }
    }

    void virtual_timer_init(void){
        /* TODO */

        // POP FIRST ELEMENT, SET FIRST TIMER
        hw_set_bits(&timer_hw->inte, 1u << 0); // alarm num = 0 always
        irq_set_exclusive_handler(TIMER_IRQ_0, lab5_timer_irq_handler);
        irq_set_enabled(TIMER_IRQ_0, true);
    }

    node_t* virtual_timer_start(uint32_t microseconds, virtual_timer_callback_t cb){
        /* TODO */
        uint32_t target = (uint32_t) timer_hw->timerawl + microseconds;
        node_t *ll_ptr = malloc (sizeof (node_t));
        ll_ptr->timer_value = target;
        ll_ptr->callback_ptr = cb;
        ll_ptr->cancel_node = false;
        ll_ptr->time_id = NULL;
        ll_ptr->alarm_num = 0;
        ll_ptr->repeat_interval = 0;
        ll_ptr->is_repeated = false;
        list_insert_sorted(ll_ptr);
        timer_hw->alarm[0] = (uint32_t) linked_list->timer_value;
        return ll_ptr;
    }

    node_t* virtual_timer_start_repeated(uint32_t microseconds, virtual_timer_callback_t cb){
        /* TODO */
        uint32_t target = (uint32_t) timer_hw->timerawl + microseconds;
        node_t *ll_ptr = malloc (sizeof (node_t));
        ll_ptr->timer_value = target;
        ll_ptr->callback_ptr = cb;
        ll_ptr->cancel_node = false;
        ll_ptr->time_id = NULL;
        ll_ptr->alarm_num = 0;
        ll_ptr->repeat_interval = target;
        ll_ptr->is_repeated = true;
        list_insert_sorted(ll_ptr);
        timer_hw->alarm[0] = (uint32_t) linked_list->timer_value;
        return ll_ptr;
    }

    node_t* virtual_timer_cancel(node_t* time_id, uint32_t microseconds){
        /* TODO */
        uint32_t target = (uint32_t) timer_hw->timerawl + microseconds;
        node_t *ll_ptr = malloc (sizeof (node_t));
        ll_ptr->timer_value = target;
        ll_ptr->callback_ptr = NULL;
        ll_ptr->cancel_node = true;
        ll_ptr->time_id = (node_t*) time_id;
        ll_ptr->alarm_num = 0;
        ll_ptr->repeat_interval = 0;
        ll_ptr->is_repeated = false;
        list_insert_sorted(ll_ptr);
        timer_hw->alarm[0] = (uint32_t) linked_list->timer_value;
        return ll_ptr;
    }

  =}


  timer print_hw_timer(0, 1000ms)
  

  reaction(startup) {=
    // initialize the LED and the virtual timer    
    gpio_init(PICO_DEFAULT_LED_PIN);
    gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);
    gpio_put(25, true);
    virtual_timer_init();
              
    // INSERT FOUR NODES
    node_t* toggle_1s_canceled = (node_t *) virtual_timer_start_repeated(1000000, led_toggle);
    virtual_timer_cancel((node_t *) toggle_1s_canceled, 5000000);
  =}
  
  reaction(print_hw_timer) -> disp.line0 {=
      /* TODO for 9.2.2 */
      
      uint32_t low = timer_hw->timelr;
      static char buf[17];
      snprintf(buf, 17, "ms: %d", low);
      lf_set(disp.line0, buf);
  =}
  /* TODO: add reaction and timer to create the environment to test */
}